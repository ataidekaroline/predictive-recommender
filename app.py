from flask import Flask, jsonify, request, render_template
import pandas as pd
import numpy as np
import os
import joblib
from surprise import dump
import sys

# Add project root to sys.path for proper module imports
sys.path.append(os.path.abspath(os.path.dirname(__file__)))

# --- CONFIGURATION & MODEL LOADING ---

MODEL_PATH = 'models/collaborative_filter.model'
HYPE_DATA_MAPPING_PATH = 'models/hype_data_mapping.pkl'
PROCESSED_DATA_FILE = 'data/processed_anime_data.csv'
MAX_SYNTHETIC_USER_ID = 200 

hype_mapping = {}
df_anime_list = pd.DataFrame()
model = None
all_anime_ids = []

try:
    # Load assets generated by recommender_model.py
    hype_mapping = joblib.load(HYPE_DATA_MAPPING_PATH)
    df_anime_list = pd.read_csv(PROCESSED_DATA_FILE)
    _, model = dump.load(MODEL_PATH)
    all_anime_ids = df_anime_list['mal_id'].unique()
    print("âœ… Models and data loaded successfully.")
except FileNotFoundError as e:
    print(f"CRITICAL: Model or data not found. Please run all scripts first! Error: {e}")


# --- FLASK APP INITIALIZATION ---
app = Flask(__name__)


# --- HELPER FUNCTION FOR DASHBOARD METRICS ---

def get_dashboard_summary():
    """Calculates key summary statistics for the dashboard."""
    if df_anime_list.empty:
        return {}

    # Total Unique Anime in Dataset
    total_anime = len(df_anime_list)
    
    # Top 3 Most Popular Genres (based on total 'scored_by' sum)
    genre_series = df_anime_list.assign(genre=df_anime_list['genres'].str.split(', ')).explode('genre')
    top_genres_df = genre_series.groupby('genre')['scored_by'].sum().reset_index()
    top_genres_df = top_genres_df.sort_values(by='scored_by', ascending=False).head(3)
    
    top_genres = top_genres_df[['genre', 'scored_by']].to_dict('records')

    # Total Scored Users (Overall community engagement)
    total_scored_users = df_anime_list['scored_by'].sum()

    return {
        "total_anime": f"{total_anime:,}",
        "total_scored_users": f"{total_scored_users:,}",
        "top_genres": top_genres
    }

# --- HYBRID PREDICTION LOGIC ---

def get_hybrid_recommendations(user_id, num_recommendations=15):
    """
    Generates hybrid recommendations combining Collaborative Filtering (SVD) 
    and the real-time Hype Score. (Logic remains the same)
    """
    if model is None or not hype_mapping:
        return []

    predictions = []
    
    for mal_id in all_anime_ids:
        pred_rating = model.predict(uid=user_id, iid=mal_id, r_ui=None).est 
        hype_data = hype_mapping.get(mal_id, {'hype_score': -1.0, 'score': 0.0, 'title': 'N/A', 'genres': 'N/A'})
        scaled_hype_boost = (hype_data['hype_score'] + 1) * 0.3 
        final_hybrid_score = pred_rating + scaled_hype_boost 
        
        predictions.append({
            'mal_id': mal_id,
            'predicted_rating_cf': pred_rating,
            'current_hype_score': hype_data['hype_score'],
            'final_hybrid_score': final_hybrid_score
        })

    df_predictions = pd.DataFrame(predictions).sort_values(
        by='final_hybrid_score', ascending=False
    )
    
    recommendations = df_predictions.merge(
        df_anime_list, on='mal_id', how='left'
    ).head(num_recommendations)
    
    results = recommendations[[
        'mal_id', 'title', 'genres', 'score', 'current_hype_score', 'final_hybrid_score'
    ]].to_dict('records')
    
    return results

# --- FRONTEND RENDERING ENDPOINTS ---

@app.route('/', methods=['GET'])
def home_recommendations():
    """Renders the main recommendation page for a default user (User 1)."""
    recommendations = get_hybrid_recommendations(user_id=1, num_recommendations=15)
    
    return render_template('index.html', 
                        user_id=1, 
                        recommendations=recommendations,
                        max_user_id=MAX_SYNTHETIC_USER_ID)

@app.route('/trends', methods=['GET'])
def render_trends_dashboard(): # FUNCTION RENAMED TO AVOID CONFLICT
    """Renders the Hype Trends Dashboard page with chart data and summary metrics."""
    # Fetches data from the /api/trends route
    trends_data = get_hype_trends().get_json().get('trends', [])
    summary = get_dashboard_summary() # Fetch summary metrics

    # Prepare data for Chart.js
    titles = [item['title'] for item in trends_data]
    # Use raw score for flexibility in the JS (raw score is -1 to 1)
    raw_hype_scores = [round(item['hype_score'], 4) for item in trends_data] 
    
    return render_template('trends.html', 
                        titles=titles, 
                        hype_scores=raw_hype_scores, 
                        summary=summary)


# --- JSON API ENDPOINTS ---

@app.route('/api/recommend/<int:user_id>', methods=['GET'])
def recommend_user(user_id):
    """API endpoint for personalized, hype-aware recommendations."""
    
    if user_id < 1 or user_id > MAX_SYNTHETIC_USER_ID: 
        return jsonify({"error": f"User ID must be between 1 and {MAX_SYNTHETIC_USER_ID} for synthetic data."}), 400

    recommendations = get_hybrid_recommendations(user_id, num_recommendations=15)
    
    return jsonify({"user_id": user_id, "recommendations": recommendations})

@app.route('/api/trends', methods=['GET'])
def get_hype_trends():
    """API endpoint for the "Hype Detector" Dashboard, showing the most talked-about items."""
    
    if df_anime_list.empty:
        return jsonify({"error": "Data not loaded. Check server logs."}), 500
        
    top_hype = df_anime_list.sort_values(by='hype_score', ascending=False).head(20)
    
    results = top_hype[[
        'mal_id', 'title', 'genres', 'score', 'hype_score', 'popularity'
    ]].to_dict('records')

    return jsonify({"trend_type": "Hype_Detector_Top_20", "trends": results})

# --- RUN APPLICATION ---

if __name__ == '__main__':
    app.run(debug=True)